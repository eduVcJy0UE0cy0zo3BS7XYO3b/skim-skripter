(define-module (ren-sexp update)
  #:use-module (ice-9 match)
  #:use-module (ice-9 atomic)
  #:use-module (dom window)
  #:use-module (ren-sexp text)
  #:use-module (ren-sexp bg)
  #:use-module (ren-sexp sprites)
  #:use-module (ren-sexp scene)
  #:use-module (ren-sexp carret)
  #:use-module (ren-sexp music)
  #:use-module (dom media)
  #:use-module (ren-sexp keyboard)
  #:use-module (ren-sexp scene-utils)
  #:use-module (hoot ffi)
  #:use-module (fibers channels)
  #:use-module (ren-sexp draw)
  #:use-module (ren-sexp utils)
  #:export (init-update))

(define (inf-ttl? scene)
  (equal? (scene-ttl scene) 'inf))

(define (next-scene-increment next current)
  (match (list next current)
    ((($ <scene> state* bg* old-text*
	 text* sprites* music* carret* ttl*)
      ($ <scene> state  bg  old-text
	 text  sprites  music  carret  ttl))
     (cond
      ((not (equal? music music*))
       (cond
        ((and (music? music)
              (not music*))
         (media-pause (music-audio music))
         (scene-update-music current music*))

        ((and (not music)
              (music? music*))
         (media-play (music-audio music*))
         (set-media-loop! (music-audio music*) 1)
         (scene-update-music current music*))))

      ((not (same-bg? bg* bg))
       (next-bg next current))
      ((not (same-sprites? sprites* sprites))
       (next-sprites next current))
      ((not (same-old-text? old-text* old-text))
       (next-old-text next current))
      ((not (same-text? text* text))
       (next-string next current))
      ((and (number? ttl) (equal? ttl* (+ 1 ttl)))
       next)
      ((not (equal? ttl ttl*))
       (next-ttl next current))
      (else next)))))

(define (compute-next-state state-box scene next)
  (if (equal? scene next)
      (if (inf-ttl? next)
	  scene
	  (append-empty-scene! state-box scene next (make-scene)))
      (next-scene-increment next scene)))

(define (init-update state-box dt)
  ;; (pk 2)
  (define draw-callback (init-draw state-box))
  (define (update)
    ;; (pk 3)
    ;; (pk (get-state))
    (let* ((state (atomic-box-ref state-box))
           (scene (assoc-ref state 'current-scene))
           (next  (assoc-ref state 'current-story-scene)))
      (define next-scene (compute-next-state state-box scene next))
      ;; (pk state)
      (atomic-update-current-scene state-box next-scene)
      ;; (pk state)
      ;; (quit)
      (request-animation-frame draw-callback)
      ;; (pk 5)
      (timeout update-callback dt)))
  (define update-callback (procedure->external update))
  update-callback)
